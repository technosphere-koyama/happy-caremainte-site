<?php

/* * **********************************
 * NAME:Ticket
 * DESC:
 *  チケット管理モジュール
 * 
 *  [概要]
 *  ユーザに、ユニークな値で認証を行うためのコードを生成する必要がある
 *  英語を入れると口頭で伝える際に面倒なことがあるので、すべて数字にて行うこととなる
 *  なので、桁数が増えることは仕方ないものとする
 *  さらに、連番を生成できるようにすると安易に他人のコードを盗まれてしまうので、
 *  連番を禁止するものとする
 *  ※連番はないが、さらに1インクリ・デクリすると存在することになるが、
 *  　永遠に存在するコードではなく(使用したら終了する)、
 *  　ユーザがいつでも認証を行えるものではなく(サイトで認証できるわけではない)、
 *  　認証する際に、範囲制限がある(店舗管轄のコード以外は通らないなど)
 *  　などの制約が存在することで、悪用されることはないと認識することとする
 * 
 * [フォーマット]
 * 	xxxx-xxxx-xxxx-xxxx
 * 	x=0～9
 * 	16桁の数値
 * 
 * 	純粋にそれだけでいくと
 * 	9,999,999,999,999,999(9,999兆)+1(全て0のパターン)までいける
 * 	なので「1景」パターン存在する
 * 	が、下記制限によって減ることになる
 * 	※どのくらい減るかは計算していない。。。
 * 
 * [制限]
 * 	各ブロック(4桁)にて同じ数値はダメ
 * 	※DBカラムを数値にするため、最初は0以外とする
 * 
 * 	過去使用したコードと重複してるか確認を行う
 * 	また、末尾1桁目の値を
 * 	インクリメントしたもの
 * 	デクリメントしたもの
 * 	が存在していないか、それらについても重複確認を行う
 * 	※これらが重複していなければ、連番にはならないので
 * 
 *	20160822
 *	10000件ほどテストで生成してみたが、
 *	重複(前後も含めて)は発生せず、ブロックごとのゾロ目が
 *	100件に満たない程度発生した
 *	ブロック毎ゾロ目率1%以下となる
 *	そのほかの制限抵触については、ログが出るようにはしているので
 *	運用の中で確認するものとする
 * 
 * [制限によるパターン実値]
 * 	最悪オーダーで考えて、連番禁止となるので、1/3となる
 * 	※1を取得すると、0と2が封印される
 * 	　次に、4を取得すると、3と5が封印される
 * 	　このパターンが一番多く封印されるパターン
 * 	　これでいくと、1/3となる
 * 
 * 	さらに、各ブロックでゾロ目を禁止する
 * 	なので、0～9それぞれのゾロ目で10パターン
 * 	それが4ブロックあるので10の4乗となるので、
 * 	10,000パターン封印される
 * 
 * 	それらでいくと、3,333兆333... -10,000パターンになると思われる
 * 	※しっかり確認していないので、確かではないが。。。
 * 
 * [データの持ち方]
 * 	テーブルはInnoDBにする
 * 	※遅くはなるが、ここ壊れると怖いのでMyISAMは使用しない
 * 	DBカラム的にはunsigned big int (16)
 * 	※検索のために、文字列ではなく数値にする
 * 	※数値にするため、最初は0以外とする
 * 	※INDEXを張る
 * 
 * NOTICE:
 * ------------------------------------------------------
 * 過去に使用した番号は、後々使用できるようにする
 * そのロジックだが、
 * ・来店確認が済んだコードはそのタイミングを保持して起き、
 * 　月1回のクーロンで、確認日から指定日数以上たっているものを削除
 * 　→クーロンの設定が面倒なので、チケット発行時にチェックして削除するものとする
 * ※ログのためにorder_eventテーブルには置いておくこと 
 * ------------------------------------------------------
 * CREATE: 2016.08.05 hesaka
 * *********************************** */
class Ticket {

	/* Constructor */
	public function __construct() {
	}

	/* ***********************************
	 * NAME  : ticketing
	 * INPUT : NONE
	 * OUTPUT: array / ブロック毎に分かれたコード配列
	 *         NULL / 生成失敗時
	 * DESC  :
	 *  チケットの発行を行う
	 * NOTICE:
	 * -----------------------------
	 *  生成済みコード(DBに保存していてまだ活きているやつ)との
	 *  重複チェックや精製後のDB登録、死にチケットのテーブル移動も併せて行う
	 * -----------------------------
	 * CREATE: 2016.08.05 hesaka
	 * *********************************** */
	public function ticketing() {

		$code = NULL;

		if (CONF::read('TICKET.IS_ACTIVE') === true) {

			$tcm = new TicketCodeModel();
			$code = $tcm->get_ticket_code(
				CONF::read('TICKET.GENERATE_RETRY_TIMES'), 
				CONF::read('TICKET.NUMBER_OF_BLOCKS'), 
				CONF::read('TICKET.NUMBER_OF_DIGITS')
			);
			//空の場合はエラー
			if (StaticFunction::is_empty($code)) {
				LOGS_ERR("TICKETING ERROR!");
				$code = NULL;
			}
		}

		//取得に成功した場合は、ブロック配列のまま返す
		return $code;
	}

	/* ***********************************
	 * NAME  : collect_ticket
	 * INPUT : NONE
	 * OUTPUT: true / finish成功
	 *         false / finish失敗
	 * DESC  :
	 *  チケットの回収(使用)を行う
	 * NOTICE:
	 *  これ以降、当該チケットは無効となる
	 * CREATE: 2016.08.05 hesaka
	 * *********************************** */
	public function collect_ticket($blocks = NULL) {

		//パラメータチェック
		if (StaticFunction::is_empty($blocks) || !is_array($blocks)) {
			LOGS_ERR("INVALID PARAMETER!");
			return false;
		}

		/*
		 * 指定チケットコードのレコードの終了フラグをONへ
		 */
		$ticket_code = implode('', $blocks);
		$tcm = new TicketCodeModel();
		if (!$tcm->collect($ticket_code)) {
			//失敗した場合
			LOGS_ERR("COLLECT TICKET ERROR! ticket_code=" . $ticket_code);
			return false;
		}

		LOGS_DBG_LV1("COLLECT TICKET COMPLETE! ticket_code=" . $ticket_code);
		return true;
	}

}

?>